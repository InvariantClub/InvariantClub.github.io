import{_ as a,D as t,c as i,I as s,U as n,o as r,a3 as o,a4 as l}from"./chunks/framework.ALnBf2yK.js";const f=JSON.parse('{"title":"Packaging 128 languages with Nix","description":"","frontmatter":{"title":"Packaging 128 languages with Nix","author":"Noon van der Silk","date":"2026-01-30T00:00:00.000Z","prev":{"text":"Getting started with Nix (and Flakes)","link":"/articles/get-started-nix-flakes"},"next":false},"headers":[],"relativePath":"articles/packaging-128-programming-languages-with-nix.md","filePath":"articles/packaging-128-programming-languages-with-nix.md"}'),h={name:"articles/packaging-128-programming-languages-with-nix.md"},p=n('<p><img src="'+o+`" alt="Quine relay logo: 128 languages"><small> Image credit: @mame&#39;s <a href="https://github.com/mame/quine-relay" target="_blank" rel="noreferrer">quine-relay</a> project. </small></p><hr><p>The famous <a href="https://github.com/mame/quine-relay" target="_blank" rel="noreferrer">quine-relay</a> by <a href="https://github.com/mame" target="_blank" rel="noreferrer">@mame</a> project builds a so-called &quot;uroboros&quot; <a href="https://en.wikipedia.org/wiki/Quine_(computing)" target="_blank" rel="noreferrer">quine</a> through 128 languages; i.e. from ruby to rust to scala to guile to .... all the way back to ruby again, where the final output ruby program is exactly equal to the original ruby program.</p><p>Clearly, this is an awesome achievement!</p><p>But, have you tried to run it yourself? If you have, you might have found it hard to reproduce. As of the time of writing, the Docker build fails. I don&#39;t run Ubuntu, so I can&#39;t tell if all the apt-get install commands work; maybe they do, but maybe not.</p><p>So, there&#39;s a natural idea. Indeed, one that <a href="https://github.com/NixOS/nixpkgs/issues/131492" target="_blank" rel="noreferrer">someone else had all the way back in 2021</a>. What if we package it with Nix? Then we can get a simple invocation, <code>nix build ...</code> that will produce the final output.</p><p>This seemed like a fun challenge, and a good test for Nix: Would we be able to do it? And if so, at what cost?</p><p>Let&#39;s get into it.</p><h3 id="can-we-do-it" tabindex="-1">Can we do it? <a class="header-anchor" href="#can-we-do-it" aria-label="Permalink to &quot;Can we do it?&quot;">‚Äã</a></h3><p>Even before getting started, we know the answer to this: Yes. The <a href="https://github.com/mame/quine-relay/wiki/Language-inclusion-criteria" target="_blank" rel="noreferrer">premise of including a particular language</a> is that it should either be available in Ubuntu, or otherwise expressible as a simple ruby program.</p><p>So that&#39;s simple: it can definitely be done. If it can be built for Ubuntu, we can either see if it&#39;s already on <a href="https://search.nixos.org/packages" target="_blank" rel="noreferrer">nixpkgs</a>, and if not, work out how to build it from source.</p><p>Motivation high; it&#39;s now down to our willingness to do a bunch of hacking. Let&#39;s get started.</p><h3 id="how-did-we-do-it" tabindex="-1">How did we do it? <a class="header-anchor" href="#how-did-we-do-it" aria-label="Permalink to &quot;How did we do it?&quot;">‚Äã</a></h3><p>Given the large package set already available through nixpkgs, the task <em>should</em> be pretty simple, and can be broken into two parts:</p><ul><li>Those already in Nix,</li><li>Those we have to manually package.</li></ul><h4 id="languages-already-in-nix" tabindex="-1">Languages already in Nix <a class="header-anchor" href="#languages-already-in-nix" aria-label="Permalink to &quot;Languages already in Nix&quot;">‚Äã</a></h4><p>Luckly, a large portion of the languages we needed were already packaged in Nix.</p><p>Those were: ruby, rust, scala, guile, scilab, sed, slang, standard-ml, surgescript, swift, tcl, tc, typescript, vala, verilog, vim, vb, wasm, xslt, yab, zsh, ada, algol, aspectj, asymptote, ats, awk, bash, bc, beanshell, c, cpp, csharp, clojure, cmake, cobol, coffeescript, clisp, crystal, d, dhall, elixir, elisp, erlang, execline, fsharp, flex, fish, forth, fortran77, fortran90, gap, gdb, gnuplot, go, golfscript, groovy, gzip, haskell, haxe, icon, jasmine, java, javascript, jq, kotlin, ksh, llvm, lolcode, lua, m4, make, minizinc, modula2 (almost), msil, mustache, nasm, neko, nim, objectivec, ocaml, octave, pari, pascal, perl5, perl6 (raku), php, pike, postscript, prolog, spin, python, r, rc, rexx, (and ruby again!)</p><p>This is actually almost all of them: 95 languages. That leaves in principle 33 languages we have to do something a little more complicated for; in practice it&#39;s fewer as <a href="https://github.com/mame/" target="_blank" rel="noreferrer">mame</a> has ruby versions of interpreters for a few of the more esoteric languages.</p><p>Our approach for languages <em>already</em> in Nix was to just write a bunch of expressions ultimately of this form:</p><div class="language-nix vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">nix</span><pre class="shiki shiki-themes min-light nord vp-code"><code><span class="line"><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;">ruby</span><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;"> =</span><span style="--shiki-light:#D32F2F;--shiki-dark:#81A1C1;"> ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;">rust</span><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;"> =</span><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;"> with</span><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;"> pkgs</span><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;">;</span><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;"> stdenv</span><span style="--shiki-light:#D32F2F;--shiki-dark:#81A1C1;">.</span><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;">mkDerivation</span><span style="--shiki-light:#24292EFF;--shiki-dark:#ECEFF4;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#8FBCBB;">  src</span><span style="--shiki-light:#D32F2F;--shiki-dark:#81A1C1;"> =</span><span style="--shiki-light:#22863A;--shiki-dark:#ECEFF4;"> &quot;</span><span style="--shiki-light:#22863A;--shiki-dark:#81A1C1;">\${</span><span style="--shiki-light:#22863A;--shiki-dark:#D8DEE9;">ruby</span><span style="--shiki-light:#D32F2F;--shiki-dark:#81A1C1;">.</span><span style="--shiki-light:#22863A;--shiki-dark:#D8DEE9;">out</span><span style="--shiki-light:#22863A;--shiki-dark:#81A1C1;">}</span><span style="--shiki-light:#22863A;--shiki-dark:#A3BE8C;">/share</span><span style="--shiki-light:#22863A;--shiki-dark:#ECEFF4;">&quot;</span><span style="--shiki-light:#24292EFF;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#8FBCBB;">  nativeBuildInputs</span><span style="--shiki-light:#D32F2F;--shiki-dark:#81A1C1;"> =</span><span style="--shiki-light:#24292EFF;--shiki-dark:#ECEFF4;"> [</span><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;"> rust</span><span style="--shiki-light:#24292EFF;--shiki-dark:#ECEFF4;"> ]</span><span style="--shiki-light:#24292EFF;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#8FBCBB;">  buildPhase</span><span style="--shiki-light:#D32F2F;--shiki-dark:#81A1C1;"> =</span><span style="--shiki-light:#22863A;--shiki-dark:#ECEFF4;"> &#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#A3BE8C;">    rustc QR.rs</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#A3BE8C;">    ./QR &gt; QR.scala</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#ECEFF4;">  &#39;&#39;</span><span style="--shiki-light:#24292EFF;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#8FBCBB;">  installPhase</span><span style="--shiki-light:#D32F2F;--shiki-dark:#81A1C1;"> =</span><span style="--shiki-light:#22863A;--shiki-dark:#ECEFF4;"> &#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#A3BE8C;">    mkdir -p $out/share</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#A3BE8C;">    cp QR.scala $out/share/</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#ECEFF4;">  &#39;&#39;</span><span style="--shiki-light:#24292EFF;--shiki-dark:#81A1C1;">;</span></span>
<span class="line"><span style="--shiki-light:#24292EFF;--shiki-dark:#ECEFF4;">}</span><span style="--shiki-light:#24292EFF;--shiki-dark:#D8DEE9;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>While there was a little bit of extra busywork, this basic format will actually served for every step: at the nth step, look at step n-1 and step n+1 to work out what to produce.</p><p>The only question is how we get the necessary compilers/interpreters for the languages that aren&#39;t present.</p><h3 id="languages-we-had-to-manually-package" tabindex="-1">Languages we had to manually package <a class="header-anchor" href="#languages-we-had-to-manually-package" aria-label="Permalink to &quot;Languages we had to manually package&quot;">‚Äã</a></h3><p>For all but a few, the approach was this:</p><ol><li>Find the source code,</li><li>Clone it,</li><li>Try and build it with Nix,</li><li>If that works, great!</li></ol><p>With a little hacking here and there, adding in necessary build-time dependencies, this worked for basically all the languages aside from <em>gambas3</em> and <em>modula-2</em>.</p><p>These two proved difficult for some kind-of interesting reasons.</p><h5 id="gambas3" tabindex="-1">gambas3 <a class="header-anchor" href="#gambas3" aria-label="Permalink to &quot;gambas3&quot;">‚Äã</a></h5><p><a href="https://gambaswiki.org/wiki" target="_blank" rel="noreferrer">Gambas</a> is a basic-like programming language. If you follow the expected process and just try and build it (after adding the necessary dependencies) you would find that it fails at runtime.</p><p>Glancing around the sourcecode, you can find that there is a large number of references to <code>/usr/lib/...</code>. If you use <a href="https://nixos.org/" target="_blank" rel="noreferrer">NixOS</a>, you will spot this as an immediate issue. If some program is explicitly expecting these paths to exist, they will be disappointed with prejudice.</p><p>The solution is to make use of the <code>buildFHSEnv</code> function which creates a runtime environment for packages like that to execute in.</p><h5 id="modula-2" tabindex="-1">modula-2 <a class="header-anchor" href="#modula-2" aria-label="Permalink to &quot;modula-2&quot;">‚Äã</a></h5><p>This one was a bit of a personal journey in learning a little bit more about Nix.</p><p>If you try and trackdown where the modula-2 sourcecode is, you find it&#39;s in <a href="https://gcc.gnu.org/" target="_blank" rel="noreferrer">&quot;gcc&quot;</a> - the GNU compiler collection.</p><p>Great news!</p><p>In fact, that library is actually already an essential part of nixpkgs: <a href="https://ryantm.github.io/nixpkgs/stdenv/stdenv/" target="_blank" rel="noreferrer">stdenv</a>, and is just a simple package on nixpkgs: <a href="https://search.nixos.org/packages?channel=25.11&amp;query=gcc" target="_blank" rel="noreferrer">gcc on nixpkgs</a>.</p><p>But, if you glance at the source code for that derivation, it&#39;s quite complicated. And taking a look around, you can see that there&#39;s a place where different languages are configured: <a href="https://github.com/NixOS/nixpkgs/blob/nixos-25.11/pkgs/development/compilers/gcc/common/configure-flags.nix#L210" target="_blank" rel="noreferrer">configure-flags.nix</a>, but <code>m2</code> is missing as an option.</p><p>At this point, I tried to make a patch to nixpkgs directly to add it. For whatever reason, it didn&#39;t work, and I discarded that idea.</p><p>Next, I tried to build <em>just</em> the m2 part of the <a href="https://github.com/gcc-mirror/gcc" target="_blank" rel="noreferrer">gcc codebase</a> &quot;manually&quot;; i.e. by writing by a Nix derivation that was &quot;good enough&quot;. This was a mistake. The main complaint I want to make here is against monorepos. It&#39;s surprisingly hard to just isolate a small part that you want to build, even in an only-moderately complicated codebase, let alone one like gcc. I kept running into problems that were clearly addressed by all the code in nixpkgs; but I didn&#39;t want to have to spend hours trying to work out all those details.</p><p>In the end I actually found a <em>different</em> implementation of modula-2 in <a href="https://github.com/davidgiven/ack" target="_blank" rel="noreferrer">ack</a>; and used that (briefly). This did work, and for me just highlights the benefits of smaller isolated repositories: easier to build only the thing you care about.</p><p>In the end I actually did come back to gcc&#39;s m2 through an elegant approach by <a href="https://github.com/SandaruKasa/quine-relay/blob/nix/nix/gm2.nix#L13" target="_blank" rel="noreferrer">SandaruKasa</a> (more on Sandaru in a moment); namely, to just use the <code>overrideAttrs</code> capability to enable m2. This then works perfectly!</p><p>It was done! I could run <code>nix build</code> and get a resulting <code>QR.rb</code> file that was exactly equal to the original! üéâ</p><h3 id="surprise-conclusion" tabindex="-1">Surprise conclusion? <a class="header-anchor" href="#surprise-conclusion" aria-label="Permalink to &quot;Surprise conclusion?&quot;">‚Äã</a></h3><p>So I did this, and submitted my PR and it was diligently accepted? And I basked in my own brilliance and unique ability to achieve this personal goal? Not exactly.</p><p>Before I started this, I was a good citizen and I searched the PRs on the repo to see if anyone had tried; there were no results. In fact there were no open PRs at all. So fine, I rolled up my sleeves and got to work.</p><p>After a few late evenings of hacking, I was ready to <a href="https://github.com/mame/quine-relay/pull/163" target="_blank" rel="noreferrer">write up my PR</a>). As I was writing, I half-noticed that there was one open PR; &quot;oh&quot; I thought, &quot;that&#39;s interesting, I&#39;ll have a look in a moment&quot;. I typed up my thoughts, and submitted.</p><p>I sat back, and waited for the love to roll in. &quot;May as well see what that PR is about&quot; I thought. <a href="https://github.com/mame/quine-relay/pull/162" target="_blank" rel="noreferrer">I clicked it</a>, and found ...</p><p><a href="https://github.com/mame/quine-relay/pull/162" target="_blank" rel="noreferrer"><img src="`+l+'" alt="Sandaru&#39;s Nix PR"></a></p><p>üò≤ ü§Ø !</p><p><a href="https://github.com/SandaruKasa" target="_blank" rel="noreferrer">@SandaruKasa</a> had the exact same idea as me at basically the exact same time, and submitted their PR a few days before me!</p><p>I started taking a close look. Sandaru resolved many similar problems to me; often in a more elegant way. Both our approaches <a href="https://github.com/mame/quine-relay/pull/162#issuecomment-3809480520" target="_blank" rel="noreferrer">worked</a>, and indeed we could both take interesting ideas from each others approach.</p><p>I was actually quite excited by this. First, I was very happy to learn from Sandaru, and have since refactored and improved my approach. Secondly, it also demonstrates the &quot;ease&quot; of packaging things with Nix: there was nothing unique that was required; merely dedication to getting it done. There wasn&#39;t only one magic solution to discover; it was possible to achieve the outcome in a variety of ways!</p><p>For me this is the best possible outcome.</p><h3 id="concluding-thoughts" tabindex="-1">Concluding thoughts <a class="header-anchor" href="#concluding-thoughts" aria-label="Permalink to &quot;Concluding thoughts&quot;">‚Äã</a></h3><p>So is that it? Is Nix amazingly perfect and should be immediately adopted for every programming language? Maybe.</p><p>But I will note that there is a world of difference between simply <em>running</em> a programming languages compiler or interpreter; and doing every-day incremeintal development <em>and</em> keep a maintainable Nix setup that works for everyone in your team. Some programming language ecosystems are better set up with Nix than others in this sense.</p><p>But the good news, is that all of this can be improved. And the benefits you get are huge!</p><h2 id="appendix" tabindex="-1">Appendix <a class="header-anchor" href="#appendix" aria-label="Permalink to &quot;Appendix&quot;">‚Äã</a></h2><h3 id="lessons-learned" tabindex="-1">Lessons learned <a class="header-anchor" href="#lessons-learned" aria-label="Permalink to &quot;Lessons learned&quot;">‚Äã</a></h3><ul><li><p><a href="https://ryantm.github.io/nixpkgs/builders/special/fhs-environments/" target="_blank" rel="noreferrer">buildFHSEnv</a></p><p>You may recall this is how I got gambas working. Because it is not a <em>requirement</em> for an <code>*nix</code> operating-system to have <code>/usr/lib/...</code> - yet a lot of applications assume that it (and similar paths) will exist - this is a very convenient tool for wrapping those programs so that they can still execute.</p></li><li><p><code>overrideAttrs</code> and <a href="https://ryantm.github.io/nixpkgs/using/overrides/" target="_blank" rel="noreferrer">overriding in general</a></p><p>Sandaru used this beautifully to bring in <code>gm2</code> from the already-heavily-configured <a href="https://github.com/NixOS/nixpkgs/blob/nixos-25.11/pkgs/build-support/cc-wrapper/default.nix#L1001" target="_blank" rel="noreferrer">gcc package</a>.</p><p>This quite trivially solved a very complex problem: How to build a very large and complex package? Luckily, in the case of such a popular package, as we&#39;ve seen, there&#39;s a very good chance it&#39;s already in nixpkgs!</p></li><li><p>If something doesn&#39;t work, check another version on <a href="https://github.com/NixOS/nixpkgs" target="_blank" rel="noreferrer">nixpkgs</a></p><p>Often, if something in whatever commit/branch of nixpkgs you&#39;ve decided to use doesn&#39;t work, you may find it works in a more recent or older version.</p><p>This was true here for Swift.</p><p>Luckily, it&#39;s a very simple matter to just try a different version; by adding a new flake input: <code>nixpkgs2505.url = &quot;github:nixos/nixpkgs/nixos-25.05&quot;;</code>. In this way you can try any commit you like!</p></li><li><p>Parallel builds</p><p>This is perhaps minor, but useful to remember: in your derivations you can set <code>enableParallelBuilding</code> which will then allow Nix to ... build whatever it can in parallel. Depending on your computer, this can <em>wildly</em> speed up your iteration process!</p></li><li><p>Patching is amazing ‚ù§Ô∏è</p><p>the <code>mkDerivation</code> function allows you to supply a list of patches (i.e. <code>git diff ...</code> outputs) that it can apply to the source tree. This is a very convenient strategy for quickly getting a build that works. In this particular process, it was important to be making progress; so my technique was to patch wildly, and then go back and refine the patch (in almost all cases entirely replace it with <code>sed</code>-style replacements) once the entire build was complete.</p><p>This is a nice incremental-kind of refactoring that keeps you productive and pragmatic, but allows room for precision when you need it.</p></li><li><p>Open source is amazing!</p><p>In fact, quite clearly, patching would be very hard if the code wasn&#39;t open-source. Even though I&#39;ve worked as a programmer for over 25 years now, I still found myself amazed at how useful it was to be able to see and change the code to get it to work, even say 10 or 15 years after it was originally released. Amazing.</p></li><li><p>Monorepo&#39;s can be frustrating</p><p>Of course monorepos are controversial, and they can be both extremely pragmatic and productive. Myself personally I&#39;m open-minded.</p><p>But, while hacking on this I noticed that, if you just want <em>part</em> of a monorepo, they can be extremely inconvenient; because, unless it&#39;s done <em>extremely well</em>, as an external consumer, you need to take into your head the whole structure of all the parts you <em>don&#39;t</em> care about; i.e. you need to work out what depends on what, and how to exclude the things you don&#39;t care about.</p><p>This, at least, was <em>not</em> an aspect of monorepo&#39;s that I had personally previously considered.</p></li><li><p>Why use stable nixpkgs?</p><p>One thing that occured to me recently is that, when working on many projects (or perhaps your company has 100s of repositories), it pays off big to use a stable input for <code>nixpkgs</code>; i.e. <code>nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-25.11</code>. This allows for the most re-use of build outputs between all your various projects.</p></li><li><p><a href="https://bmcgee.ie/posts/2023/02/nix-what-are-fixed-output-derivations-and-why-use-them/" target="_blank" rel="noreferrer">Fixed-output derivations</a> (FODs) can be useful</p><p>A typical Nix derivation cannot access the internet; this is because the goal is reproducibility, and any kind of internet access could result in a difference next time.</p><p>But what if you need to access the internet? To download a package? (or even just source code?! which we do all the time.)</p><p>The solution to this is simple and elegant: just declare the hash of the contents you are expecting to receive! Nix then permits the derivation to access the network, but will error out if the resulting hash doesn&#39;t match.</p><p>This is useful for package managers that don&#39;t allow you to disable checks to the internet; or for packaging steps that require downloading some dependencies.</p></li></ul><h3 id="the-code" tabindex="-1">The code <a class="header-anchor" href="#the-code" aria-label="Permalink to &quot;The code&quot;">‚Äã</a></h3><p>My changes are easiest to browse here: <a href="https://github.com/silky/quine-relay/tree/nix/nix" target="_blank" rel="noreferrer">silky/quine-relay/nix</a>.</p><p>There you can find:</p><ul><li>the <code>flake.nix</code> entrypoint,</li><li><code>pkgs.nix</code> which has all the Nix derivations for the packages that weren&#39;t in nixpkgs</li><li><code>outputs.nix</code> that has each step of the quine expressed as a simple call, ultimately, to <code>mkDerivation ...</code></li></ul><p>If you prefer, you can just run it like so:</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes min-light nord vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#88C0D0;">nix</span><span style="--shiki-light:#2B5581;--shiki-dark:#A3BE8C;"> build</span><span style="--shiki-light:#2B5581;--shiki-dark:#A3BE8C;"> github:silky/quine-relay/nix</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Then you will find all the source files in <code>./result</code>.</p><p>Perhaps the most fun, at least for me personally, was to see what the resulting <a href="https://esolangs.org/wiki/Piet" target="_blank" rel="noreferrer">piet program</a> looks like (check <code>./result/php-to-piet/share/QR.png</code>.)</p><h3 id="bonus-content" tabindex="-1">Bonus content <a class="header-anchor" href="#bonus-content" aria-label="Permalink to &quot;Bonus content&quot;">‚Äã</a></h3><p>If you feel like playing around adding some new languages, take a look at this PR: <a href="https://github.com/silky/quine-relay/pull/2" target="_blank" rel="noreferrer">Experiment with other languages</a>; you just need to look at editing <a href="https://github.com/silky/quine-relay/blob/more-languages/src/code-gen.rb" target="_blank" rel="noreferrer">./src/code-gen.rb</a> and then run <code>rake</code> to generate <code>QR.rb</code>.</p>',71);function d(c,u,g,m,k,y){const e=t("ArticleHeader");return r(),i("div",null,[s(e,{title:"Packaging 128 languages with Nix",author:"Noon van der Silk",image:"noon"}),p])}const w=a(h,[["render",d]]);export{f as __pageData,w as default};
