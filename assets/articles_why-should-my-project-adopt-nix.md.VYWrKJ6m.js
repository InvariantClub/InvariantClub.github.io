import{_ as e,c as a,o as s,U as n}from"./chunks/framework.q5Cqz01-.js";const m=JSON.parse('{"title":"Why should my project adopt Nix?","description":"","frontmatter":{"title":"Why should my project adopt Nix?","author":"Noon van der Silk","date":"2026-01-07T00:00:00.000Z","next":false,"prev":false},"headers":[],"relativePath":"articles/why-should-my-project-adopt-nix.md","filePath":"articles/why-should-my-project-adopt-nix.md","lastUpdated":null}'),o={name:"articles/why-should-my-project-adopt-nix.md"},t=n(`<h1 id="why-should-my-project-adopt-nix" tabindex="-1">Why should my project adopt Nix? <a class="header-anchor" href="#why-should-my-project-adopt-nix" aria-label="Permalink to &quot;Why should my project adopt Nix?&quot;">‚Äã</a></h1><p>Perhaps someone has submitted a PR adding a <code>flake.nix</code> to your repo. Perhaps you have been reading about <a href="https://nixos.org/" target="_blank" rel="noreferrer">Nix</a>; talking to your friends, watching your colleagues, or even overheard a passer-by on the street mention Nix. In any case, you are curious and inspired: What is Nix? Why might you want to adopt it? Especially in a project that is otherwise seemingly &quot;working fine&quot;?</p><p>Let&#39;s take a look, at a high level, and from the perspective of someone who has not used Nix before, why you might consider it, and potential drawbacks. But first, let&#39;s address the most natural question: <em>Why add yet another package manager?</em></p><h2 id="is-nix-just-yet-another-package-manager" tabindex="-1">Is Nix just Yet Another Package Manager? <a class="header-anchor" href="#is-nix-just-yet-another-package-manager" aria-label="Permalink to &quot;Is Nix just Yet Another Package Manager?&quot;">‚Äã</a></h2><p>In some ways, yes. But, unlike your language-level package managers, Nix is effectively a system-wide package mananger. That is, it lets you <em>install</em> the language-level package managers you need! And in particular, in most cases, it actually reads all the information it needs about compiling your project, from the package manager you already use in your language of choice.</p><p>For example, in the Python ecosystem it is becoming popular to use <a href="https://docs.astral.sh/uv/" target="_blank" rel="noreferrer">uv</a>; a Nix-based Python project would use <a href="https://pyproject-nix.github.io/uv2nix/" target="_blank" rel="noreferrer">uv2nix</a> to read the uv-specified dependencies and load them into your environment.</p><p>What differentiates Nix from your typical (language-based) package managers is that it can also install things <em>outside</em> of that language; i.e. other depednencies you may have; data-transformation tools, database clients, websocket clients, etc. At this point, almost any package you can dream of is available on what we called &quot;<a href="https://github.com/NixOS/nixpkgs/" target="_blank" rel="noreferrer">nixpkgs</a>&quot;; you can search for what you use here: <a href="https://search.nixos.org/packages" target="_blank" rel="noreferrer">search.nixos.org</a>. Feel free to try it out right now; there&#39;s an extremely high chance your tool of choice is there!</p><div class="info custom-block"><p class="custom-block-title">üëÄ Observation</p><p>Nix let&#39;s you declare and install <em>all</em> of your projects dependencies, instead of just the ones related to your language. This works across all<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> systems.</p><br><p>It is the last package manager you will ever need!</p></div><p>With that out of the way, let&#39;s get into the benefits.</p><h2 id="consistent-isolated-development-environments" tabindex="-1">Consistent, isolated development environments <a class="header-anchor" href="#consistent-isolated-development-environments" aria-label="Permalink to &quot;Consistent, isolated development environments&quot;">‚Äã</a></h2><p>Depending on what ecosystem&#39;s you&#39;ve been working in; you might now have a follow-up question: How do you get isolation of <em>system</em>-level dependencies? The answer is, in essence, through the <a href="https://nix.dev/manual/nix/2.24/store/" target="_blank" rel="noreferrer">Nix store</a>. All the dependencies you install end up in the store; organised by a hash of their contents.</p><p>This means that you get <em>re-use</em> across different projects, if they depend on the same version of certain packages! Contrast this with npm or Python, where each virtual environment maintains it&#39;s own version of potentially the same library.</p><div class="info custom-block"><p class="custom-block-title">üëÄ Observation</p><p>Nix isolates dependencies in it&#39;s own store.</p></div><p>The essence of the store, and in many ways Nix itself, is the idea of storing packages in a folder named after the hash of the contents. This has a surprising number of benefits; namely in re-use and caching.</p><p>In day to day use, the interaction and engagement with these development environments can be completely seamless: you <code>cd</code> into the directory of your project, and immediately all your tools are present and ready. You <code>cd</code> out; and they are gone.</p><p>This is achieved through a combination of <a href="https://nixos.wiki/wiki/flakes" target="_blank" rel="noreferrer">Nix flakes</a>, <a href="https://nix.dev/tutorials/first-steps/declarative-shell.html" target="_blank" rel="noreferrer">devShells</a> and <a href="https://direnv.net/" target="_blank" rel="noreferrer">direnv</a>.</p><p>An example of this:</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#ABB2BF;">&gt; node</span></span>
<span class="line"><span style="color:#61AFEF;">zsh:</span><span style="color:#98C379;"> command</span><span style="color:#98C379;"> not</span><span style="color:#98C379;"> found:</span><span style="color:#98C379;"> node</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">&gt; cd frontend</span></span>
<span class="line"><span style="color:#61AFEF;">direnv:</span><span style="color:#98C379;"> loading</span><span style="color:#98C379;"> ~/dev/.../frontend/.envrc</span></span>
<span class="line"><span style="color:#61AFEF;">direnv:</span><span style="color:#98C379;"> using</span><span style="color:#98C379;"> flake</span></span>
<span class="line"><span style="color:#61AFEF;">direnv:</span><span style="color:#98C379;"> nix-direnv:</span><span style="color:#98C379;"> Using</span><span style="color:#98C379;"> cached</span><span style="color:#98C379;"> dev</span><span style="color:#98C379;"> shell</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">&gt; node</span></span>
<span class="line"><span style="color:#61AFEF;">Welcome</span><span style="color:#98C379;"> to</span><span style="color:#98C379;"> Node.js</span><span style="color:#98C379;"> v18.18.2.</span></span>
<span class="line"><span style="color:#61AFEF;">Type</span><span style="color:#98C379;"> &quot;.help&quot;</span><span style="color:#98C379;"> for</span><span style="color:#98C379;"> more</span><span style="color:#98C379;"> information.</span></span>
<span class="line"><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">&gt; cd ..</span></span>
<span class="line"><span style="color:#61AFEF;">direnv:</span><span style="color:#98C379;"> unloading</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Note that merely enterining into the directory gets me the tools that I need. This setup is compatible with all IDEs.</p><h2 id="reproducibility-and-caching-less-compute-‚ù§Ô∏è-üåç" tabindex="-1">Reproducibility and caching (less compute! <span>‚ù§Ô∏è üåç</span>) <a class="header-anchor" href="#reproducibility-and-caching-less-compute-‚ù§Ô∏è-üåç" aria-label="Permalink to &quot;Reproducibility and caching (less compute! &lt;span&gt;‚ù§Ô∏è üåç&lt;/span&gt;)&quot;">‚Äã</a></h2><p>Because of Nix&#39;s hashing approach; it is a moderately simple matter to determine if it needs to do work rebuilding, or if it can just use some previously-built artefact. It simply computes the hash of the entire dependency tree, and any point which has the same hash can be re-used.</p><p>This can be hugely efficient.</p><p>Combined with using a Nix cache (either your own, or a hosted one, on the popular service <a href="https://www.cachix.org/" target="_blank" rel="noreferrer">cachix</a>) you can wildly reduce the amount of rebuilds that you do between peers.</p><div class="info custom-block"><p class="custom-block-title">üëÄ Observation</p><p>Content-based hashing means no rebuilding things that haven&#39;t changed; this means faster build times and less compute resources required!</p></div><h2 id="provision-of-entrypoints-and-other-scripts" tabindex="-1">Provision of entrypoints, and other scripts <a class="header-anchor" href="#provision-of-entrypoints-and-other-scripts" aria-label="Permalink to &quot;Provision of entrypoints, and other scripts&quot;">‚Äã</a></h2><p>Imagine you&#39;d like to provide a way for someone to run your project. Or, you&#39;d like to have some helper scripts to working with your repository. With an appropriately-specified <code>flake.nix</code> file all of this comes for free.</p><p>Consider an example; the <a href="https://github.com/ERGO-Code/HiGHS" target="_blank" rel="noreferrer">HiGHS</a> linear optimisation program. You can run it <em>directly</em> from GitHub with the following command:</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#61AFEF;">nix</span><span style="color:#98C379;"> run</span><span style="color:#98C379;"> github:ERGO-Code/HiGHS/v1.12.0</span><span style="color:#D19A66;"> --</span><span style="color:#D19A66;"> --version</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>This feature is extremely powerful. Note that above we have specified a specific branch; so indeed you can specific any revision you like, and hence very easily share different versions of your executables with users.</p><p>In general the power you get is to fully specify any binaries in the resulting environment, and indeed even environment variables themselves, and in this way you can define a consistent set of scripts to be used within your team.</p><h2 id="simplified-ci" tabindex="-1">Simplified CI <a class="header-anchor" href="#simplified-ci" aria-label="Permalink to &quot;Simplified CI&quot;">‚Äã</a></h2><p>Following immediately from above, with everything declared in appropriate nix files, there is reduced need for complicated <code>ci</code> files: most of the logic can live in the appropriate Nix expressions.</p><p>This not only keeps sophisticated logic out of vendor-specific CI runners; but also makes it significantly easier to run CI locally.</p><h2 id="deployment" tabindex="-1">Deployment <a class="header-anchor" href="#deployment" aria-label="Permalink to &quot;Deployment&quot;">‚Äã</a></h2><p>We&#39;ve already seen that you can provide executables directly via the <code>flake.nix</code> file. But, you may also wish to, perhaps, provide your application in a docker environment.</p><p>This turns out to be extremely trivial as well, with Nix&#39;s <a href="https://ryantm.github.io/nixpkgs/builders/images/dockertools/" target="_blank" rel="noreferrer">dockerTools</a> functions. It&#39;s outside the scope of this article to go into detail; but the main point is, once you have an ability to construct and execute a binary, many things follow very simply from there. This can even include capabilities such as cross-compiling a binary for different architectures; or building distributable static binaries, etc.</p><h2 id="huge-ecosystem-of-available-packages" tabindex="-1">Huge ecosystem of available packages <a class="header-anchor" href="#huge-ecosystem-of-available-packages" aria-label="Permalink to &quot;Huge ecosystem of available packages&quot;">‚Äã</a></h2><p>There is a <em>very</em> active community bringing almost any program and package you can dream of into Nix. Joyfully, it is also very simple to make use of them; here is a collection of examples to run, say, the <a href="https://qgis.org/" target="_blank" rel="noreferrer">QGIS</a> Geospatial analysis software; Python at vesion 3.13; the program <a href="https://en.wikipedia.org/wiki/Inkscape" target="_blank" rel="noreferrer">Inkscape</a>, and even Python with some particular packages available.</p><p>Here&#39;s a selection of examples:</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#61AFEF;">nix</span><span style="color:#98C379;"> run</span><span style="color:#98C379;"> nixpkgs#qgis</span></span>
<span class="line"><span style="color:#61AFEF;">nix</span><span style="color:#98C379;"> run</span><span style="color:#98C379;"> nixpkgs#python313</span></span>
<span class="line"><span style="color:#61AFEF;">nix</span><span style="color:#98C379;"> run</span><span style="color:#98C379;"> nixpkgs#inkscape</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Python3 + Jupyter + Pandas:</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#ABB2BF;">&gt; nix-shell -p </span><span style="color:#98C379;">&quot;python3.withPackages ( ps: [ ps.jupyter ps.pandas ] )&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;">&gt; jupyter notebook</span></span>
<span class="line"><span style="color:#56B6C2;">...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Postgres:</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#ABB2BF;">&gt; nix-shell -p postgresql</span></span>
<span class="line"><span style="color:#ABB2BF;">&gt; psql --version</span></span>
<span class="line"><span style="color:#61AFEF;">psql</span><span style="color:#ABB2BF;"> (PostgreSQL) 17.7</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Take a look for yourself: <a href="https://search.nixos.org/packages" target="_blank" rel="noreferrer">search.nixos.org</a> the package you want is almost certainly on there.</p><h2 id="wildly-simplified-onboarding-of-new-users" tabindex="-1">Wildly simplified onboarding of new users <a class="header-anchor" href="#wildly-simplified-onboarding-of-new-users" aria-label="Permalink to &quot;Wildly simplified onboarding of new users&quot;">‚Äã</a></h2><p>By reflecting on the above, you should now be able to see that onboarding new users in this setup becomes much simpler.</p><ul><li>They can run your app through a simple <code>nix run ...</code>,</li><li>They can immediately enter a working development shell with all tools installed,</li><li>There&#39;s no need to follow a list of instructions in the Readme about how to get setup.</li></ul><p>You can even provision full demo/testing environments with <a href="https://github.com/F1bonacc1/process-compose" target="_blank" rel="noreferrer">process-compose</a> so that users can immediately run what might be a complicated app with multiple startup dependencies and initialisation scripts.</p><h2 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to &quot;Conclusion&quot;">‚Äã</a></h2><p>Naturally, not all these benefits come easily or at not cost. Writing <code>.nix</code> files can take a little work; and occasionally you will need to do some hacking to get your exact case to work. But what I can promise is that the investment in Nix pays off: you can always get things working eventually; and the benefits are worth the effort.</p><p>If you&#39;re inspired to try, a good place to start would be our <a href="/templates/">Nix templates</a>!</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Here I&#39;m referring to Linux and MacOS systems. This includes Windows as well, when you build within WSL. <a href="#fnref1" class="footnote-backref">‚Ü©Ô∏é</a></p></li></ol></section>`,54),i=[t];function r(l,p,c,d,h,u){return s(),a("div",null,i)}const f=e(o,[["render",r]]);export{m as __pageData,f as default};
